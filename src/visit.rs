// Copyright 2021 Martin Pool

//! Visit the abstract syntax tree and discover things to mutate.
//!
//! Knowledge of the syn API is localized here.

use quote::ToTokens;
use syn::visit::Visit;
use syn::Attribute;
use syn::ItemFn;

use crate::mutate::{Mutation, MutationOp};
use crate::source::SourceFile;

/// `syn` visitor that recursively traverses the syntax tree, accumulating places that could be mutated.
pub struct DiscoveryVisitor<'sf> {
    /// All the mutations generated by visiting the file.
    pub mutations: Vec<Mutation>,

    /// The file being visited.
    source_file: &'sf SourceFile,

    /// The stack of namespaces we're currently inside.
    namespace_stack: Vec<String>,
}

impl<'sf> DiscoveryVisitor<'sf> {
    pub fn new(source_file: &'sf SourceFile) -> DiscoveryVisitor<'sf> {
        DiscoveryVisitor {
            source_file,
            mutations: Vec::new(),
            namespace_stack: Vec::new(),
        }
    }

    fn collect_mutation(&mut self, op: MutationOp, item_fn: &ItemFn) {
        self.namespace_stack.push(item_fn.sig.ident.to_string());
        let function_name = self.namespace_stack.join("::");
        let return_type = format!("{}", item_fn.sig.output.to_token_stream());
        self.mutations.push(Mutation::new(
            self.source_file.clone(),
            op,
            function_name,
            return_type,
            item_fn.block.brace_token.span.into(),
        ));
        self.namespace_stack.pop();
    }
}

impl<'ast, 'sf> Visit<'ast> for DiscoveryVisitor<'sf> {
    // TODO: Also visit methods and maybe closures.

    fn visit_item_fn(&mut self, item_fn: &'ast ItemFn) {
        // TODO: Filter out more inapplicable fns.
        if attrs_excluded(&item_fn.attrs) {
            return; // don't look inside it either
        }
        // Look at the return type and try to work out what values might be valid to return.
        let mut ops: Vec<MutationOp> = Vec::new();
        match &item_fn.sig.output {
            syn::ReturnType::Default => ops.push(MutationOp::Unit),
            syn::ReturnType::Type(_rarrow, box_typ) => match &**box_typ {
                syn::Type::Path(syn::TypePath { path, .. }) => {
                    // dbg!(&path);
                    if path.is_ident("bool") {
                        ops.push(MutationOp::True);
                        ops.push(MutationOp::False);
                    } else if path.is_ident("String") {
                        // TODO: Detect &str etc.
                        ops.push(MutationOp::EmptyString);
                        ops.push(MutationOp::Xyzzy);
                    } else if path_is_result(path) {
                        // TODO: Try this for any path ending in "Result".
                        // TODO: Recursively generate for types inside the Ok side of the Result.
                        ops.push(MutationOp::OkDefault);
                    } else {
                        ops.push(MutationOp::Default)
                    }
                }
                _ => ops.push(MutationOp::Default),
            },
        }
        ops.into_iter()
            .for_each(|op| self.collect_mutation(op, item_fn));
        syn::visit::visit_item_fn(self, item_fn);
    }

    fn visit_item_mod(&mut self, node: &'ast syn::ItemMod) {
        // TODO: Remember which mods we're inside, and put the path into the name of visited
        // functions.
        if !attrs_excluded(&node.attrs) {
            let name = node.ident.to_string();
            self.namespace_stack.push(name.clone());
            syn::visit::visit_item_mod(self, node);
            assert_eq!(self.namespace_stack.pop(), Some(name));
        }
    }
}

fn path_is_result(path: &syn::Path) -> bool {
    path.segments
        .last()
        .map(|segment| segment.ident == "Result")
        .unwrap_or_default()
}

/// True if any of the attrs indicate that we should skip this node and everything inside it.
fn attrs_excluded(attrs: &[Attribute]) -> bool {
    attrs
        .iter()
        .any(|attr| attr_is_cfg_test(attr) || attr_is_test(attr) || attr_is_mutants_skip(attr))
}

/// True if the attribute is `#[cfg(test)]`.
fn attr_is_cfg_test(attr: &Attribute) -> bool {
    if !attr.path.is_ident("cfg") {
        return false;
    }
    if let syn::Meta::List(meta_list) = attr.parse_meta().unwrap() {
        // We should have already checked this above, but to make sure:
        assert!(meta_list.path.is_ident("cfg"));
        for nested_meta in meta_list.nested {
            if let syn::NestedMeta::Meta(syn::Meta::Path(cfg_path)) = nested_meta {
                if cfg_path.is_ident("test") {
                    return true;
                }
            }
        }
    }
    false
}

/// True if the attribute is `#[test]`.
fn attr_is_test(attr: &Attribute) -> bool {
    attr.path.is_ident("test")
}

/// True if the attribute is `#[mutants::skip]`.
fn attr_is_mutants_skip(attr: &Attribute) -> bool {
    attr.path
        .segments
        .iter()
        .map(|ps| &ps.ident)
        .eq(["mutants", "skip"].iter())
}

#[cfg(test)]
mod test {
    #[test]
    fn path_is_result() {
        let path: syn::Path = syn::parse_quote! { Result<(), ()> };
        assert!(super::path_is_result(&path));
    }
}
